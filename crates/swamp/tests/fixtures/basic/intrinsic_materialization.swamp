// Tests for the previous primitive intrinsic materialization bug
//
// Ensures that intrinsics work correctly when:
// - Source is a memory location (struct field, variable)
// - Destination is a memory location (struct field, tuple element)
// - Both source and destination are memory locations

struct TestData {
    int_value: Int,
    float_value: Float,
    result_int: Int,
    result_float: Float,
}

#[test]
fn float_round_literal() {
    assert(100.9.round() == 101, "round literal is wrong")
}

#[test]
fn float_floor_literal() {
    assert(100.9.floor() == 100, "floor literal is wrong")
}

#[test]
fn float_abs_literal() {
    assert((-3.5).abs() == 3.5, "abs literal is wrong")
}

#[test]
fn int_to_float_literal() {
    assert(42.to_float() == 42.0, "int to_float literal is wrong")
}

#[test]
fn float_round_from_struct_field() {
    data = TestData { int_value: 42, float_value: 100.9, result_int: 0, result_float: 0.0 }
    result = data.float_value.round()
    assert(result == 101, "round from struct field is wrong")
}

#[test]
fn float_floor_from_struct_field() {
    data = TestData { int_value: 42, float_value: 100.9, result_int: 0, result_float: 0.0 }
    result = data.float_value.floor()
    assert(result == 100, "floor from struct field is wrong")
}

#[test]
fn int_to_float_from_struct_field() {
    data = TestData { int_value: 42, float_value: 0.0, result_int: 0, result_float: 0.0 }
    result = data.int_value.to_float()
    assert(result == 42.0, "int to_float from struct field is wrong")
}

#[test]
fn float_round_to_struct_field() {
    mut data = TestData { int_value: 0, float_value: 100.9, result_int: 0, result_float: 0.0 }
    data.result_int = data.float_value.round()
    assert(data.result_int == 101, "round to struct field is wrong")
}

#[test]
fn int_to_float_to_struct_field() {
    mut data = TestData { int_value: 42, float_value: 0.0, result_int: 0, result_float: 0.0 }
    data.result_float = data.int_value.to_float()
    assert(data.result_float == 42.0, "int to_float to struct field is wrong")
}

#[test]
fn float_floor_to_tuple() {
    x = 1.9
    a, b = (x.floor(), 2.0)
    assert(a == 1, "floor to tuple first element is wrong")
    assert(b == 2.0, "second element unchanged in tuple")
}

#[test]
fn int_to_float_to_tuple() {
    x = 42
    float_result = x.to_float()
    a, b = (float_result, 3.0)
    assert(a == 42.0, "int to_float to tuple first element is wrong")
    assert(b == 3.0, "second element unchanged in tuple")
}

#[test]
fn float_abs_struct_to_struct() {
    source_data = TestData { int_value: 0, float_value: -3.5, result_int: 0, result_float: 0.0 }
    mut dest_data = TestData { int_value: 0, float_value: 0.0, result_int: 0, result_float: 0.0 }
    dest_data.result_float = source_data.float_value.abs()
    assert(dest_data.result_float == 3.5, "abs struct to struct is wrong")
}

#[test]
fn int_abs_struct_to_struct() {
    source_data = TestData { int_value: -42, float_value: 0.0, result_int: 0, result_float: 0.0 }
    mut dest_data = TestData { int_value: 0, float_value: 0.0, result_int: 0, result_float: 0.0 }
    dest_data.result_int = source_data.int_value.abs()
    assert(dest_data.result_int == 42, "int abs struct to struct is wrong")
}

#[test]
fn complex_expression_with_struct_fields() {
    data = TestData { int_value: 10, float_value: 3.7, result_int: 0, result_float: 0.0 }
    int_as_float = data.int_value.to_float()
    sum = int_as_float + data.float_value
    result = sum.floor()
    assert(result == 13, "complex expression with struct fields is wrong")
}

#[test]
fn float_sqrt_from_variable() {
    x = 16.0
    result = x.sqrt()
    assert(result == 4.0, "sqrt from variable is wrong")
}

#[test]
fn int_max_from_variables() {
    a = 5
    b = 10
    result = a.max(b)
    assert(result == 10, "int max from variables is wrong")
}

#[test]
fn int_to_string_from_struct() {
    data = TestData { int_value: 123, float_value: 0.0, result_int: 0, result_float: 0.0 }
    result = data.int_value.string()
    assert(result == "123", "int to_string from struct is wrong")
}

#[test]
fn float_to_string_from_struct() {
    data = TestData { int_value: 0, float_value: 3.14, result_int: 0, result_float: 0.0 }
    result = data.float_value.string()
    assert(result == "3.140", "float to_string from struct is wrong")
}

#[test]
fn chained_intrinsics_from_struct() {
    data = TestData { int_value: -42, float_value: 0.0, result_int: 0, result_float: 0.0 }
    result = data.int_value.abs().to_float().sqrt().floor()
    assert(result == 6, "chained intrinsics from struct is wrong") // sqrt(42) about 6.48, floor = 6
}
