/*
TODO: Implement "true" views in the future
#[test]
fn vector_slice() {
    a = [10, 20, 30, 40]

    b = a[1..3]
    assert(b == [20, 30, 40], 'should have been equal {b}')
}
*/

#[test]
fn vector_slice() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 32> = a.slice(1..3)

    print('b:{b}')

    assert(b.capacity() == 32, "should still have 32 in capacity")

    assert(b.len() == 2, 'len failed {b.len()}')

    c: Vec<Int; 4> = a.slice(1..=3)

    print('c:{c}')

    assert(c.capacity() == 4, "should still have 4 in capacity")
    // TODO: c == [20, 30, 40] // did not work!

    assert(c.len() == 3, 'len failed {c.len()}')

    assert(c[0] == 20, 'not equal {c[0]}')
    assert(c[1] == 30, 'not equal {c[1]}')
    assert(c[2] == 40, 'not equal {c[2]}')
}

#[test]
fn slice_undefined() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(0..0)
    assert(b.len() == 0, 'len was wrong {b.len()}')
}

#[test]
fn slice_one() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(0..1)
    assert(b.len() == 1, 'len was wrong {b.len()}')
}

#[test]
#[should_trap(expected="vec_bounds_fail")]
fn slice_is_out_of_bounds() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 32> = a.slice(4..7)
}

#[test]
#[should_trap(expected="vec_out_of_capacity")]
fn slice_target_is_too_small() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(0..=2) // slice is 3 in length, but target capacity is just 2
}

#[test]
#[should_trap(expected="reverse_range_not_allowed_here")]
fn slice_is_wrong_order() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(3..1)
}
