/*
TODO: Implement "true" views in the future
#[test]
fn vector_slice() {
    a = [10, 20, 30, 40]

    b = a[1..3]
    assert(b == [20, 30, 40], 'should have been equal {b}')
}
*/

#[test]
fn vector_slice() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 32> = a.slice(1..3)

    print('b:{b}')

    assert(b.capacity() == 32, "should still have 32 in capacity")

    assert(b.len() == 2, 'len failed {b.len()}')

    c: Vec<Int; 4> = a.slice(1..=3)

    print('c:{c}')

    assert(c.capacity() == 4, "should still have 4 in capacity")
    // TODO: Compare with vec likes should work
    // assert(c == [20, 30, 40], 'equals should work')
    assert(c.len() == 3, 'len failed {c.len()}')

    assert(c[0] == 20, 'not equal {c[0]}')
    assert(c[1] == 30, 'not equal {c[1]}')
    assert(c[2] == 40, 'not equal {c[2]}')
}

#[test]
fn slice_undefined() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(0..0)
    assert(b.len() == 0, 'len was wrong {b.len()}')
}

#[test]
fn slice_one() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(0..1)
    assert(b.len() == 1, 'len was wrong {b.len()}')
}

#[test]
#[should_trap(expected="vec_bounds_fail")]
fn slice_is_out_of_bounds() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 32> = a.slice(4..7)
}

#[test]
#[should_trap(expected="vec_out_of_capacity")]
fn slice_target_is_too_small() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(0..=2) // slice is 3 in length, but target capacity is just 2
}

#[test]
#[should_trap(expected="reverse_range_not_allowed_here")]
fn slice_is_wrong_order() {
    a = [10, 20, 30, 40]

    b: Vec<Int; 2> = a.slice(3..1)
}


struct SliceTarget {
    other: Int,
    numbers: Vec<Int; 2>,
}

impl SliceTarget {

    // The bug only happened if another self field
    // was set before the slice
    fn function_that_fills_slice(mut self, data: Vec<Int; 4>) {
        self.other = 42
        self.numbers = data.slice(1..3)
    }

}

/// # Problem
/// Reported by @catnipped. The `VecSlice` intrinsic was grabbing the
/// output destination's memory address directly instead of flattening it
/// via `emit_compute_effective_address_to_register`.
///
/// # Fix
/// Change `VecSlice` to compute the effective address of the destination
/// into a register before use-ensuring it's properly "flattened".
#[test]
fn slice_target() {
    mut target = SliceTarget {..}

    data = [10, 20, 30, 40]

    target.function_that_fills_slice(data)
}
