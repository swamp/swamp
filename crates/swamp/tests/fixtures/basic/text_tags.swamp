enum ArgValue {
    Int Int,
    Float Float,
    Bool Bool,
    Hex [Byte; 4],
    Keyword String,
    Str String,
}

struct Element {
    name: String<32>,
    args: [String: ArgValue; 8]
}

enum Node {
    Element Element,
    Text String,
}

struct Parser {
    is_eof: Bool,
    str: String<256>,
    region_stack: Stack<Int; 32>, // keep track on where region started
    pos: Int,
    nodes: Vec<Node; 256>,
}

impl Parser {
    fn new() -> Parser {
        Parser {..}
    }

    fn next(mut self) -> Byte {
        if self.pos == self.str.len() {
            self.is_eof = true
            b' '
        } else {
            ch = self.str[self.pos]
            self.pos += 1
            if self.pos == self.str.len() {
                self.is_eof = true
            }
            ch
        }
    }

    fn skip(mut self) {
        if self.pos == self.str.len() {
            self.is_eof = true
        } else {
            print('skipping: {self.str[self.pos].char()}')
            self.pos += 1
        }
    }

    fn peek(mut self) -> Byte {
        if self.pos == self.str.len() {
            self.is_eof = true
            print('peek {self.pos} end')
            b' '
        } else {
            print('peek {self.pos} ch:"{self.str[self.pos].char()}"')
            self.str[self.pos]
        }
    }

    fn skip_ws(mut self) {
        while self.peek() == b' ' {
            self.skip()
        }
    }

    fn starts_with(self, str: String) -> Bool {
        rest = self.str.slice(self.pos..self.str.len())
        rest.starts_with(str)
    }

    fn parse_identifier(mut self, mut raw_name: Vec<Byte>) {
        mut done = false
        while !done && !self.is_eof {
            ch = self.peek()
            if (ch >= b'a' && ch <= b'z') || ch == b'_' {
                raw_name.push(ch)
                self.skip()
            } else {
                done = true
            }
        }
    }


    fn parse_text_until_space_or_end_bracket(mut self) -> String {
        mut raw_text : Vec<Byte; 64> = []
        mut done = false
        while !done && !self.is_eof {
            ch = self.peek()
            if ch == b']' || ch == b' ' {
                done = true
            } else if self.is_eof {
                done = true
            }else {
                // TODO: Handle escaped \[ or \]
                self.skip()
                raw_text.push(ch)
            }
        }
        raw_text
    }

    fn parse_number(mut self) -> ArgValue {
        print('parsing number')
        s = self.parse_text_until_space_or_end_bracket()
        print('parsing number returned "{s}"')
        int_value, int_worked = s.int()
        if int_worked {
            print('found int {int_value}')
            ArgValue::Int(int_value)
        } else {
            float_value, float_worked = s.float()
            ArgValue::Float(float_value)
        }
    }

    fn parse_integer(mut self) -> Int {
        s = self.parse_text_until_space_or_end_bracket()
        int_value, int_worked = s.int()
        int_value
    }

    fn parse_byte(mut self) -> Byte {
        self.parse_integer()
    }

    fn parse_rgb(mut self) -> ArgValue {
        for _ in 0..4 self.skip() // skip `rgb(`
        r = self.parse_byte()
        self.skip() // skip `,`
        g = self.parse_byte()
        self.skip() // skip `,`
        b = self.parse_byte()
        self.skip() // skip `)`

        ArgValue::Hex([r, g, b])
    }

    fn parse_rgba(mut self) -> ArgValue {
        for _ in 0..4 self.skip() // skip `rgba`
        ArgValue::Hex([b' ', b' ', b' ', b' '])
    }

    fn parse_hex(mut self) -> ArgValue {
        ArgValue::Hex([b' ', b' ', b' ', b' '])
    }

    fn parse_text_value(mut self) -> ArgValue {
        self.skip()
        ArgValue::Str("hello")
    }


    fn parse_value(mut self) -> ArgValue {
        first = self.peek()
        print('peek in value {first.char()}')

        | self.starts_with("rgb") -> self.parse_rgb()
        | self.starts_with("rgba") -> self.parse_rgba()
        | self.starts_with("true") -> ArgValue::Bool(true)
        | self.starts_with("false") -> ArgValue::Bool(false)
        | first == b'#' -> self.parse_hex()
        | first == b'"' -> self.parse_text_value()
        | _ -> self.parse_number()
    }


    fn parse_args(mut self, mut args: [String:ArgValue]) {
        mut done = false
        mut raw_name: Vec<Byte; 42> = []
        mut first = true
        print('parse args!!')
        while !done && !self.is_eof {
            if self.peek() == b']' {
                done = true
            } else {
                if !first {
                    print('parse identifier')
                    self.skip_ws()
                    self.parse_identifier(&raw_name)
                                    print('identifier done {raw_name}')


                    self.skip_ws()
                    ch = self.next()
                    assert(ch == b'=', 'must have equals after, but got "{ch}"')
                } else {
                    print('no identifier first')
                    raw_name = "value"
                }

                first = false

                self.skip_ws()

                print('check end or value')

                {
                    value = self.parse_value()
                    str: String<32> = raw_name
                    print('inserting into map: {str} with {value}')
                    key = ' {str} '
                    args[key] = value
                }
            }
        }
    }

    fn read_opening_tag(mut self) {

        self.skip() // Discard `[`

        mut element = Element {
            ..
        }

        self.parse_identifier(&element.name)

        self.parse_args(&element.args)

        self.skip() // Discard `]`



        print('added element: {element}')
        self.nodes.push(Node::Element(element))
    }

    fn read_closing_tag(mut self) {
        self.skip()
    }

    fn parse_text(mut self) -> String {
        mut raw_text : Vec<Byte; 64> = []
        mut done = false
        while !done && !self.is_eof {
            ch = self.peek()
            if ch == b'[' {
                done = true
            } else if self.is_eof {
                done = true
            }else {
                // TODO: Handle escaped \[ or \]
                self.skip()
                raw_text.push(ch)
            }
        }
        raw_text
    }

    fn parse(mut self, text: String) -> [Node] {
        self.str = text
        print('>self.str: {self.str} text:{text}')
        while !self.is_eof {
            if self.starts_with("[/") {
                print('strange, it started with closing')
                self.read_closing_tag()

                //start_index = self.region_stack.pop()
            } else if self.peek() == b'[' {
                print('found start')

                name = self.read_opening_tag()
            } else {
                print('found text')
                parsed_text = self.parse_text()

                self.nodes.push(Node::Text(parsed_text))
            }
        }

        self.nodes
    }
}

#[test]
fn parse() {
    mut parser = Parser::new()

    nodes: Vec<Node; 128> = parser.parse("[test]hello [after 23 a=3] and then [color rgb(23,44,98)]")
    print('nodes: {nodes}')

    match nodes[0] {
        Element element -> {
            print('element {element}')
            assert(element.name == "test", 'element name is wrong {element.name}')
        }
        _ -> panic('should have been element'),
    }

    match nodes[1] {
        Text text -> {
            print('text {text}')
            assert(text == "hello", 'text is wrong "{text}"')
        }
        _ -> panic('should have been text'),
    }
}
