enum ArgValue {
    Int Int,
    Float Float,
    Bool Bool,
    Hex [Byte; 4],
    Keyword String,
    Str String<32>,
}

impl ArgValue {
    fn string(self) -> String {
        match self {
            Int a -> '{a}i',
            Float a -> '{a}f',
            Bool a -> '{a}',
            Hex array -> '#{array}',
            Keyword keyword -> 'keyword "{keyword}"',
            Str string -> '"{string}"',
            _ -> {
                panic('internal error')
                "error"
            }
        }
    }
}

struct Field {
    name: String<32>,
    value: ArgValue,
}

impl Field {
    fn string(self) -> String {
        '{self.name}={self.value}'
    }
}

struct Element {
    name: String<32>,
    args: Vec<Field; 8>,
}

impl Element {
    fn string(self) -> String {
        mut args = ""
        for field in self.args {
            args = args + ' {field}'
        }
        '[{self.name}{args}]'
    }
}

enum Node {
    Element Element,
    Text String<32>,
}

impl Node {
    fn string(self) -> String {
        match self {
            Element element -> '{element}',
            Text text -> '"{text}"',
            _ -> {
                panic('severe internal error')
                ""
            }
        }
    }
}

struct Parser {
    is_eof: Bool,
    str: String<256>,
    region_stack: Stack<Int; 32>, // TODO: keep track on where region started
    pos: Int,
    nodes: Vec<Node; 256>,
}

impl Parser {
    fn new() -> Parser {
        Parser {..}
    }

    fn next(mut self) -> Byte {
        if self.pos == self.str.len() {
            self.is_eof = true
            b' '
        } else {
            ch = self.str[self.pos]
            self.pos += 1
            if self.pos == self.str.len() {
                self.is_eof = true
            }
            ch
        }
    }

    fn skip(mut self) {
        if self.pos == self.str.len() {
            self.is_eof = true
        } else {
            self.pos += 1
        }
    }

    fn peek(mut self) -> Byte {
        if self.pos == self.str.len() {
            self.is_eof = true
            b' '
        } else {
            self.str[self.pos]
        }
    }

    fn skip_ws(mut self) {
        while !self.is_eof && self.peek() == b' ' {
            self.skip()
        }
    }

    fn starts_with(self, str: String) -> Bool {
        rest = self.str.slice(self.pos..self.str.len())
        rest.starts_with(str)
    }

    fn parse_identifier(mut self, mut raw_name: Vec<Byte>) {
        mut done = false
        while !done && !self.is_eof {
            ch = self.peek()
            if (ch >= b'a' && ch <= b'z') || ch == b'_' {
                raw_name.push(ch)
                self.skip()
            } else {
                done = true
            }
        }
    }

    fn parse_text_until_space_or_delimiter(mut self) -> String {
        mut raw_text : Vec<Byte; 64> = []
        mut done = false

        while !done && !self.is_eof {
            ch = self.peek()
            if ch == b']' || ch == b' ' || ch == b',' || ch == b')' || ch == b'"' {
                done = true
            } else if self.is_eof {
                done = true
            } else {
                // TODO: Handle escaped \[ or \]
                self.skip()
                raw_text.push(ch)
            }
        }

        raw_text
    }

    fn parse_text_until_quote(mut self) -> String {
        mut raw_text : Vec<Byte; 64> = []
        mut done = false

        while !done && !self.is_eof {
            ch = self.peek()
            if ch == b'"' {
                done = true
            } else if self.is_eof {
                done = true
            } else {
                self.skip()
                raw_text.push(ch)
            }
        }

        raw_text
    }

    fn parse_number(mut self) -> ArgValue {
        s = self.parse_text_until_space_or_delimiter()
        int_value, int_worked = s.int()
        if int_worked {
            ArgValue::Int(int_value)
        } else {
            float_value, float_worked = s.float()
            ArgValue::Float(float_value)
        }
    }

    fn parse_float(mut self) -> Float {
        s = self.parse_text_until_space_or_delimiter()
        float_value, float_worked = s.float()
        float_value
    }

    fn parse_integer(mut self) -> Int {
        s = self.parse_text_until_space_or_delimiter()
        int_value, int_worked = s.int()
        int_value
    }

    fn parse_byte(mut self) -> Byte {
        self.parse_integer()
    }

    fn parse_rgb(mut self) -> ArgValue {
        for _ in 0..4 self.skip() // skip `rgb(`
        r = self.parse_byte()
        self.skip_ws()
        self.skip() // skip `,`
        self.skip_ws()
        g = self.parse_byte()
        self.skip_ws()
        self.skip() // skip `,`
        self.skip_ws()
        b = self.parse_byte()
        self.skip_ws()
        self.skip() // skip `)`
        self.skip_ws()
        ArgValue::Hex([r, g, b])
    }

    fn parse_rgba(mut self) -> ArgValue {
        for _ in 0..5 self.skip() // skip `rgba(`
        r = self.parse_byte()
        self.skip_ws()
        self.skip() // skip `,`
        self.skip_ws()
        g = self.parse_byte()
        self.skip_ws()
        self.skip() // skip `,`
        self.skip_ws()
        b = self.parse_byte()
        self.skip_ws()
        self.skip() // skip `,`
        self.skip_ws()
        a: Byte = (self.parse_float() * 255.0).round()
        self.skip_ws()
        self.skip() // skip `)`
        self.skip_ws()
        ArgValue::Hex([r, g, b, a])
    }

    fn parse_hex(mut self) -> ArgValue {
        ArgValue::Hex([0, 0, 0, 0]) // TODO: implement parsing of `#42FA9908`
    }

    fn parse_text_value(mut self) -> ArgValue {
        self.skip() // skip `"`
        text = self.parse_text_until_quote()
        self.skip() // skip `"`
        ArgValue::Str(text)
    }

    fn parse_value(mut self) -> ArgValue {
        first = self.peek()

        | self.starts_with("rgba") -> self.parse_rgba()
        | self.starts_with("rgb") -> self.parse_rgb()
        | self.starts_with("true") -> ArgValue::Bool(true)
        | self.starts_with("false") -> ArgValue::Bool(false)
        | first == b'#' -> self.parse_hex()
        | first == b'"' -> self.parse_text_value()
        | _ -> self.parse_number()
    }

    fn parse_args(mut self, mut args: Vec<Field>) {
        mut done = false
        mut raw_name: String<42> = ""
        mut first = true
        while !done && !self.is_eof {
            self.skip_ws()
            if !self.is_eof {
                if self.peek() == b']' {
                    done = true
                } else {
                    if !first {
                        self.skip_ws()
                        raw_name.clear()
                        self.parse_identifier(&raw_name)
                        self.skip_ws()

                        ch = self.next()
                        assert(ch == b'=', 'must have equals after, but got "{ch}"')
                    } else {
                        raw_name = "value"
                    }

                    first = false

                    self.skip_ws()

                    {
                        value = self.parse_value()
                        str: String<32> = raw_name
                        key = ' {str} '
                        args.push( Field {
                            name: raw_name,
                            value: value,
                        } )
                    }
                }
            }
        }
    }

    fn read_opening_tag(mut self) {

        self.skip() // Discard `[`

        mut element = Element {
            ..
        }

        self.parse_identifier(&element.name)

        self.parse_args(&element.args)

        self.skip() // Discard `]`

        self.nodes.push(Node::Element(element))
    }

    fn read_closing_tag(mut self) {
        self.skip()
    }

    fn parse_text(mut self) -> String {
        mut raw_text : String<64> = ""
        mut done = false
        while !done && !self.is_eof {
            ch = self.peek()
            if ch == b'[' {
                done = true
            } else if self.is_eof {
                done = true
            }else {
                // TODO: Handle escaped \[ or \]
                self.skip()
                raw_text.push(ch)
            }
        }
        raw_text
    }

    fn parse(mut self, text: String) -> [Node] {
        self.str = text
        while !self.is_eof {
            if self.starts_with("[/") {
                self.read_closing_tag()

                //start_index = self.region_stack.pop()
            } else if self.peek() == b'[' {
                name = self.read_opening_tag()
            } else {
                parsed_text = self.parse_text()

                self.nodes.push(Node::Text(parsed_text))
            }
        }

        self.nodes
    }
}

#[test]
fn parse() {
    mut parser = Parser::new()

    nodes: Vec<Node; 128> = parser.parse('[test]hello [after 23 a=3 b="text value"] and then [color rgb(23,44,98)] [color rgba(191, 201, 233, 0.99)]')
    print('nodes: {nodes}')

    match nodes[0] {
        Element element -> {
            assert(element.name == "test", 'element name is wrong {element.name}')
        }
        _ -> panic('should have been element'),
    }

    match nodes[1] {
        Text text -> {
            assert(text == "hello ", 'text is wrong "{text}"')
        }
        _ -> panic('should have been text'),
    }
}
