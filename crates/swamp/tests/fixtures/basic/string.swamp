#[test]
fn string_equality() {
    s1 = "hello"
    s2 = "hello"
    s3 = "world"
    print('s1:{s1}, s2:{s2}, s3:{s3}')
    assert(s1 == s2, "string equality (positive) failed")
    assert(s1 != s3, "string inequality (negative) failed")
}

#[test]
fn string_concatenation() {
    part1 = "swamp"
    part2 = "-lang"
    part3 = ".org"
    combined = part1 + part2 + part3
    print('combined_string:{combined}')
    assert(combined == "swamp-lang.org", "string concatenation failed")
}

struct Something {
    a: String<42>,
}

#[test]
fn string_storage() {
    save: String<42> = "hello"

    assert(save.len() == 5, 'wrong length {save.len()}')
}


#[test]
fn string_storage_to_string_view() {
    save: String<42> = "hello"
    ephemeral: String = save

    assert(save.len() == 5, 'wrong length {save.len()}')
    assert(ephemeral.len() == 5, 'wrong length {ephemeral.len()}')
}

#[test]
fn for_loop_ascii() {
    mut codepoints = 0
    mut build_string_again = ""

    for char in "hello, world!" {
        output = char.string()
        build_string_again = build_string_again + output

        codepoints += 1
    }

    assert(codepoints == 13, 'wrong number of codepoints {codepoints}')
    assert("hello, world!" == build_string_again, 'was not equal {build_string_again}')
}

#[test]
fn for_loop_unicode() {
    mut codepoints = 0
    mut rebuilt = ""
    for c in "ðŸ§›âœ¨ðŸŒŸ" {
        // TODO: compound assignments of string doesn't work yet. e.g. `rebuilt += c.string()`
        rebuilt = rebuilt + c.string()
        print('found codepoint: {c}')
        codepoints += 1
    }
    assert(codepoints == 3, 'expected 3 codepoints, got {codepoints}')
    assert(rebuilt == "ðŸ§›âœ¨ðŸŒŸ", 'round-trip failed: {rebuilt}')
}

#[test]
fn char_int_roundtrip() {
    bytes_that_will_become_chars = [0x0, 0x41, 0x7F, 0x2603, 0x1_F9DB]
    for code in bytes_that_will_become_chars {
        c: Char = code
        assert(c.int() == code, "{code} -> Char -> Int gave {c.int()}")
    }
}

#[test]
fn char_int_roundtrip_with_temporary() {
    for code in [0x0, 0x41, 0x7F, 0x2603, 0x1_F9DB] {
        c: Char = code
        assert(c.int() == code, "{code} -> Char -> Int gave {c.int()}")
    }
}

#[test]
fn empty_string() {
    a = ""
    print(a)
    print('a: {a}')
    assert(a == "", 'string should be completely empty')
}

#[test]
fn empty_string_with_interpolation() {
    a = ''
    print(a)
    print('a: {a}')
    assert(a == "", 'string should be completely empty')
}

#[test]
fn test_append() {
    mut str = ""
    str = str + 'a word'
    print(str)
    assert(str == "a word", 'could not append')
}


#[test]
fn empty_string_behaviors() {
    mut s = ""
    assert(s.len() == 0, 'len was {s.len()}')
    assert(s.capacity() == 0, "didn't follow the capacity rules of swamp") // capacity is never allowed to be zero for a collection in Swamp
    assert(s.is_empty(), "is_empty() was wrong")
    mut iterated = 0
    for _ in "" { iterated += 1 }
    assert(iterated == 0, "should not iterate at all")
}

#[test]
fn compare_with_char() {
    mut codepoints = 0

    for index, char in "hello, world!" {
        if index == 4 {
            assert(char.int() == 111, 'char to int was wrong {char.int()}') // 111 is lowercase `o`
        }
        codepoints += 1
    }

    assert(codepoints == 13, 'wrong length {codepoints}')
}

#[test]
fn setting_a_char() {
    unicode_value: Char = 0x1_F9DB
    print('this is the char {unicode_value}')
    assert(unicode_value.string() == "ðŸ§›", 'conversion was wrong {unicode_value}')
}

#[test]
fn subscripts() {
    raw_byte = "hello, world!"[12]
    assert(raw_byte.int() == 0x21, 'must be 0x21, but was {raw_byte}') // 0x21 is the exclamation!
}

#[test]
fn subscripts_on_utf8() {
    raw_byte = "ðŸ§›!"[2] // the utf8 encoding for `vampire` is 0xF0, 0x9F, 0xA7, 0x9B
    assert(raw_byte.int() == 0xa7, 'must be 0xA7, but was {raw_byte}')
}

#[test]
fn len_on_utf8() {
    string = "ðŸ§›!" // the utf8 encoding for `vampire` is 0xF0 0x9F 0xA7 0x9B
    assert(string.len() == 5, 'should be 5, but got {string.len()}')
    assert(string.capacity() == 5, 'capacity should be 5, but got {string.capacity()}')
}

struct StringStorage {
    i: Byte,
    str: String<42>,
}

#[test]
fn store_string() {
    storage = StringStorage {
        str: "store this text",
        ..
    }
    assert(storage.str == "store this text", 'string failed to be stored {storage.str}')
    assert(storage.i.int() == 0, 'byte must be zero')
    assert(storage.i.string() == "0x00", 'byte to_string failed')
}

#[test]
fn match_with_string() {
    str = "<blood>"
    result = match str {
        "<damage>" -> "hej",
        "<vampire>" -> "\u(1F9DB)",
        "<blood>" -> "ðŸ©¸",
        _ -> "",
    }
    assert(result == "ðŸ©¸", 'should have matches {result}')
}


#[test]
fn match_with_string_guard() {
    str = "<blood>"
    age = 17
    result = match str {
        "<damage>" -> "hej",
        "<vampire>"  -> "\u(1F9DB)",
        "<blood>" | age > 18 -> "ðŸ©¸",
        "<blood>"  -> "green",
        _ -> "",
    }
    assert(result == "green", 'should have matches {result}')
}

#[test]
fn match_with_string_guard_fall_through() {
    str = "<blood>"
    age = -1
    result = match str {
        "<damage>" -> "hej",
        "<vampire>"  -> "\u(1F9DB)",
        "<blood>" | age > 18 -> "ðŸ©¸",
        "<blood>" | age > 0 -> "green",
        _ -> "not found",
    }
    assert(result == "not found", 'should have no match {result}')
}

#[test]
fn repeat_string() {
    a = ".." * 4
    assert(a == "........", 'repeat did not work {a}')
}


#[test]
fn starts_with() {
    a = "123hello"
    assert(a.starts_with("123"), 'string was not correct')
}
/*
TODO: Not working yet
#[test]
fn match_with_variables() {
    str = "<blood>"
    result = match str {
        "<damage>" -> "hej",
        "<vampire>"  -> "\u(1F9DB)",
        what_is_this -> what_is_this + "_found",
        _ -> "",
    }
    assert(result == "green", 'should have matches {result}')
}
*/

/*
struct ArtifactData {
	name: String,
	description: String,
	label: ArtifactLabel,
	template: Vec<ArtifactMod; 10>,
}*/


enum ArtifactID {
	Obsidian,
	SetCollector
}

enum ArtifactLabel {
    Blue,
    Black,
}

struct ArtifactData {
    name: String,
	description: String,
}

const ARTIFACT_LIB: [ArtifactID:ArtifactData; 100] = [
	ArtifactID::Obsidian : {
        name: "Obsidian Gemstone",
		description: "Gain one extra move action, lose 1 speed",
	},
	ArtifactID::SetCollector : {
        name: "Set Collector",
		description: 'For each {ArtifactLabel::Blue} artifact, equipped, +1 strength',
	}
]

#[test]
fn string_in_constant() {
    print('cool:{ARTIFACT_LIB[ArtifactID::SetCollector].description}')
    assert(ARTIFACT_LIB[ArtifactID::SetCollector].description == "For each ArtifactLabel::Blue artifact, equipped, +1 strength", 'was not equal {ARTIFACT_LIB[ArtifactID::SetCollector].description}')
}

/*
#[test]
fn chars_lookup() {
    string = "ðŸ§›âœ¨ðŸŒŸ"

    middle_char = string.chars()[1]
    assert(middle_char == 0x2728, 'middle char was wrong')
}
*/


enum Action {
	Move, //steps
	VenomAttack(Int), //disease amount
}

enum Keyword {
	Cloaked,
	Noble,
}

enum RegionType {
	Action(Action),
	Keyword(Keyword),
}

struct Region {
	id: Int,
	type: RegionType,
}

struct RegionString {
	string: String<2048>,
	regions: Vec<Region;20>
}

fn get_description(region_type: RegionType) -> RegionString {
	match region_type {
		Keyword keyword -> {
			mut description = RegionString {..}
			match keyword {
				Cloaked -> {
					description.string = "This unit can't be targeted unless it holds the [region 0]objective.[/region]"
				}
			}
			description
		}
		_ -> {
		    RegionString {
		        string: "hello",
		        ..
		    }
		}
    }
}


// TODO: look into this bug where strings somewhere is not set properly and is filled with zero.
#[test]
fn string_rest() {
    region_string = get_description(Keyword(Keyword::Noble))
    print('region_string: {region_string.string}')

    assert(region_string.string.is_empty(), "it should be empty, move is not handled")
}
