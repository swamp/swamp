 /// Tests for enum variant payload capacity handling
 ///
 /// # Problem
 ///
 /// When initializing enum variants with collection payloads (like Vec), the collection's capacity
 /// wasn't being properly set. This happened because:
 ///
 /// - The memory for the enum variant was allocated correctly
 /// - The tag was set correctly to identify the variant
 /// - But when initializing the payload memory, the Vec capacity field wasn't being set
 ///   to the type-defined capacity (from Vec<T;N> where N is the capacity)
 ///
 /// # Solution
 ///
 /// The initialization sequence was fixed to properly handle all payload types:
 ///
 /// -  First initialize the base payload memory
 /// -  For complex payloads (like tuples containing Vecs), calculate the correct offset
 ///    to the Vec tuple field and explicitly initialize it
 /// -  Then copy the actual content from source to destination
 ///
 /// This ensures that regardless of where a Vec appears (direct payload, in tuple, in struct),
 /// its capacity is always properly initialized to the type-defined value.
type UnitID = Int

enum EnumCapacityPayload {
    Message,
    RefreshUnits Vec<UnitID;30>,
    StructPayload { units: Vec<UnitID;40> }
}

// TODO: This fails *sometimes* which is alarming //#[test]
fn unit_payload() {
    x = EnumCapacityPayload::Message
    assert(x == EnumCapacityPayload::Message, "should be equal")
}

#[test]
fn complex_payload_empty() {
    x = EnumCapacityPayload::RefreshUnits([])

    match x {
        RefreshUnits units -> {
            print('units: {units}')
        }
    }
}

#[test]
fn complex_payload_from_other_empty_vec() {
    mut unit_id_list: Vec<UnitID; 100> = []

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 0, 'len wrong {unit_id_list.len()}')

    x = EnumCapacityPayload::RefreshUnits(unit_id_list)

    match x {
        RefreshUnits units -> {
            print('units: {units}')
        }
    }
}

#[test]
fn complex_payload_from_other_vec() {
    mut unit_id_list: Vec<UnitID; 100> = []

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 0, 'len wrong {unit_id_list.len()}')

    for i in 0..23 {
        unit_id_list.push(i)
    }

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 23, 'len wrong {unit_id_list.len()}')

    x = EnumCapacityPayload::RefreshUnits(unit_id_list)
    match x {
        RefreshUnits units -> {
            assert(units.capacity() == 30, 'struct payload capacity wrong {units.capacity()}')
            assert(units.len() == 23, 'struct payload len wrong {units.len()}')
        }
        _ -> {
            panic("wrong variant matched")
        }
    }
}

#[test]
fn struct_payload_with_vec() {
    mut unit_id_list: Vec<UnitID; 100> = []

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 0, 'len wrong {unit_id_list.len()}')

    for i in 0..15 {
        unit_id_list.push(i)
    }

    assert(unit_id_list.capacity() == 100, 'capacity wrong {unit_id_list.capacity()}')
    assert(unit_id_list.len() == 15, 'len wrong {unit_id_list.len()}')

    x = EnumCapacityPayload::StructPayload { units: unit_id_list }

    match x {
        StructPayload { units } -> {
            assert(units.capacity() == 40, 'struct payload capacity wrong {units.capacity()}')
            assert(units.len() == 15, 'struct payload len wrong {units.len()}')
        }
        _ -> {
            panic("wrong variant matched")
        }
    }
}
